R2DBC
=====
1. JPA is a specification
    It is for traditional synchronous programming.
2. R2DBC is a separate specification
    For reactive programming.
3. R2DBC != JPA
4. Prioritizes
    1. Performance
    2. Scalability
    3. Streaming + Backpressure
5. It does NOT have features like
    @OneToMany
    @ManyToMany

Driver Implementations
======================
1. oracle
2. h2
3. maria
4. mssql
5. mysql
6. postgresql

Driver Config
=============
h2 - r2dbc:h2:mem:///userdb
postgres - r2dbc:postgresql://localhost:5432/userdb
mysql - r2dbc:mysql://localhost:3306/userdb

Reactive Manifesto => Reactive Systems
======================================
Responsive      - The ability of the system to react / respond quickly.
Resilient       - The ability of the system to stay responsive even in case of failures.
Elastic         - The ability of the system to stay responsive even under varying workload / system resources.
Message Driven  - The ability of the systems to communicate using the messages in a non-blocking manner
                  by applying back pressure if necessary.

Need for DTO (Data Transfer Object)
============
Advantages
==========
     1. Decoupling
            DB Table vs API
     2. Security
            Data exposure
            Customer entity might have password field. CustomerDTO might not have passsword.
     3. Versioning
     4. Validation

Problem Detail
==============
Type    - A link to the documentation for the callers to read more about the problem. If its not
          provided. "about:blank" is assumed.
title   - Human readable summary of the problem.
status  - HTTP status code.
detail  - Detailed message specific to the problem.
instance- The URI which caused the problem.

Web Client
==========
1. Reactor based fluent API for making HTTP requests.
    Wrapper around reactor-netty.
2. Non-Blocking.
3. Immutable.
4. Thread safe.

Using WebFlux, the APIs will be exposed for the application.
Using WebClient the request is sent to remote services.

Streaming Advantages
====================
1. We will setup connection once and keep sending the messages in a streaming fashion.
2. No need to wait for previous request to complete.
3. Reduced Network traffic / latency.
4. You can use JSON to create a product / item.

JSON Line (Have advantage over JSON Array)
=========
1. AKA ND-JSON [new-line delimited]
2. Each line is 1 JSON object
    a. self contained
    b. easy to parse
    c. great for streaming
    d. massive datasets
3. JSON array is good for smaller and related data.
   Example: Reviews for a product.

gZip
====
1. If the response size is large (in KBs), it will take more time for the client to receive.
2. Client might observe increased response time. The apps might appear to be performing poorly.
3. But it could be just network latency.

1. gZip is a technique to compress the response before sending over the network.
2. It will work well in congested network + response size is large.
Note:
====
1. Server requires additional processing to compress.
2. It might have negative effect when the response size is small.
3. Do NOT use local machine to test. You will not see any improvement.

Server Side:
===========
server.compression.enabled=true
server.compression.min-response-size=2048
server.compression.mime-types=application/json,application/xml

Client Side Request Header:
===========================
Accept-Encoding: gzip

Connection Pooling
==================
1. Connection setup takes time.
2. Keep-alive => to reuse connections.
3. HTTP 1.1
    a. 1 connection per request.

Below Command to Monitor Network Connections
============================================
The below command to monitor the network connections.

Netstat command to monitor the network connections
netstat -an| grep -w 127.0.0.1.7070

To watch
watch 'netstat -an| grep -w 127.0.0.1.7070'